/**
 * @fileoverview added by tsickle
 * Generated from: lib/sortablejs.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, Inject, Input, NgZone, Optional, Output, Renderer2, } from '@angular/core';
import Sortable from 'sortablejs';
import { GLOBALS } from './globals';
import { SortablejsBindings } from './sortablejs-bindings';
import { SortablejsService } from './sortablejs.service';
/** @type {?} */
const getIndexesFromEvent = (/**
 * @param {?} event
 * @return {?}
 */
(event) => {
    if (event.hasOwnProperty('newDraggableIndex') && event.hasOwnProperty('oldDraggableIndex')) {
        return {
            new: event.newDraggableIndex,
            old: event.oldDraggableIndex,
        };
    }
    else {
        return {
            new: event.newIndex,
            old: event.oldIndex,
        };
    }
});
const ɵ0 = getIndexesFromEvent;
export class SortablejsDirective {
    /**
     * @param {?} globalConfig
     * @param {?} service
     * @param {?} element
     * @param {?} zone
     * @param {?} renderer
     */
    constructor(globalConfig, service, element, zone, renderer) {
        this.globalConfig = globalConfig;
        this.service = service;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        this.sortablejsInit = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (Sortable && Sortable.create) { // Sortable does not exist in angular universal (SSR)
            this.create();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const optionsChange = changes.sortablejsOptions;
        if (optionsChange && !optionsChange.isFirstChange()) {
            /** @type {?} */
            const previousOptions = optionsChange.previousValue;
            /** @type {?} */
            const currentOptions = optionsChange.currentValue;
            Object.keys(currentOptions).forEach((/**
             * @param {?} optionName
             * @return {?}
             */
            optionName => {
                if (currentOptions[optionName] !== previousOptions[optionName]) {
                    // use low-level option setter
                    this.sortableInstance.option(optionName, this.options[optionName]);
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.sortableInstance) {
            this.sortableInstance.destroy();
        }
    }
    /**
     * @private
     * @return {?}
     */
    create() {
        /** @type {?} */
        const container = this.sortablejsContainer ? this.element.nativeElement.querySelector(this.sortablejsContainer) : this.element.nativeElement;
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.sortableInstance = Sortable.create(container, this.options);
            this.sortablejsInit.emit(this.sortableInstance);
        }), 0);
    }
    /**
     * @private
     * @return {?}
     */
    getBindings() {
        if (!this.sortablejs) {
            return new SortablejsBindings([]);
        }
        else if (this.sortablejs instanceof SortablejsBindings) {
            return this.sortablejs;
        }
        else {
            return new SortablejsBindings([this.sortablejs]);
        }
    }
    /**
     * @private
     * @return {?}
     */
    get options() {
        return Object.assign(Object.assign({}, this.optionsWithoutEvents), this.overridenOptions);
    }
    /**
     * @private
     * @return {?}
     */
    get optionsWithoutEvents() {
        return Object.assign(Object.assign({}, (this.globalConfig || {})), (this.sortablejsOptions || {}));
    }
    /**
     * @private
     * @param {?} eventName
     * @param {...?} params
     * @return {?}
     */
    proxyEvent(eventName, ...params) {
        this.zone.run((/**
         * @return {?}
         */
        () => {
            if (this.optionsWithoutEvents && this.optionsWithoutEvents[eventName]) {
                this.optionsWithoutEvents[eventName](...params);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    get isCloning() {
        return this.sortableInstance.options.group.checkPull(this.sortableInstance, this.sortableInstance) === 'clone';
    }
    /**
     * @private
     * @template T
     * @param {?} item
     * @return {?}
     */
    clone(item) {
        // by default pass the item through, no cloning performed
        return (this.sortablejsCloneFunction || ((/**
         * @param {?} subitem
         * @return {?}
         */
        subitem => subitem)))(item);
    }
    /**
     * @private
     * @return {?}
     */
    get overridenOptions() {
        // always intercept standard events but act only in case items are set (bindingEnabled)
        // allows to forget about tracking this.items changes
        return {
            onAdd: (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.service.transfer = (/**
                 * @param {?} items
                 * @return {?}
                 */
                (items) => {
                    this.getBindings().injectIntoEvery(event.newIndex, items);
                    this.proxyEvent('onAdd', event);
                });
                this.proxyEvent('onAddOriginal', event);
            }),
            onRemove: (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                /** @type {?} */
                const bindings = this.getBindings();
                if (bindings.provided) {
                    if (this.isCloning) {
                        this.service.transfer(bindings.getFromEvery(event.oldIndex).map((/**
                         * @param {?} item
                         * @return {?}
                         */
                        item => this.clone(item))));
                        // great thanks to https://github.com/tauu
                        // event.item is the original item from the source list which is moved to the target list
                        // event.clone is a clone of the original item and will be added to source list
                        // If bindings are provided, adding the item dom element to the target list causes artifacts
                        // as it interferes with the rendering performed by the angular template.
                        // Therefore we remove it immediately and also move the original item back to the source list.
                        // (event handler may be attached to the original item and not its clone, therefore keeping
                        // the original dom node, circumvents side effects )
                        this.renderer.removeChild(event.item.parentNode, event.item);
                        this.renderer.insertBefore(event.clone.parentNode, event.item, event.clone);
                        this.renderer.removeChild(event.clone.parentNode, event.clone);
                    }
                    else {
                        this.service.transfer(bindings.extractFromEvery(event.oldIndex));
                    }
                    this.service.transfer = null;
                }
                this.proxyEvent('onRemove', event);
            }),
            onUpdate: (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                /** @type {?} */
                const bindings = this.getBindings();
                /** @type {?} */
                const indexes = getIndexesFromEvent(event);
                bindings.injectIntoEvery(indexes.new, bindings.extractFromEvery(indexes.old));
                this.proxyEvent('onUpdate', event);
            }),
        };
    }
}
SortablejsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sortablejs]',
            },] }
];
/** @nocollapse */
SortablejsDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [GLOBALS,] }] },
    { type: SortablejsService },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
SortablejsDirective.propDecorators = {
    sortablejs: [{ type: Input }],
    sortablejsContainer: [{ type: Input }],
    sortablejsOptions: [{ type: Input }],
    sortablejsCloneFunction: [{ type: Input }],
    sortablejsInit: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SortablejsDirective.prototype.sortablejs;
    /** @type {?} */
    SortablejsDirective.prototype.sortablejsContainer;
    /** @type {?} */
    SortablejsDirective.prototype.sortablejsOptions;
    /** @type {?} */
    SortablejsDirective.prototype.sortablejsCloneFunction;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.sortableInstance;
    /** @type {?} */
    SortablejsDirective.prototype.sortablejsInit;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.globalConfig;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.service;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    SortablejsDirective.prototype.renderer;
}
/**
 * @record
 */
function SortableEvent() { }
if (false) {
    /** @type {?} */
    SortableEvent.prototype.oldIndex;
    /** @type {?} */
    SortableEvent.prototype.newIndex;
    /** @type {?|undefined} */
    SortableEvent.prototype.oldDraggableIndex;
    /** @type {?|undefined} */
    SortableEvent.prototype.newDraggableIndex;
    /** @type {?} */
    SortableEvent.prototype.item;
    /** @type {?} */
    SortableEvent.prototype.clone;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydGFibGVqcy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNvcnRhYmxlanMvc3JjLyIsInNvdXJjZXMiOlsibGliL3NvcnRhYmxlanMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBQ0wsTUFBTSxFQUlOLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxHQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sUUFBbUIsTUFBTSxZQUFZLENBQUM7QUFDN0MsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNsQyxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQzs7TUFJakQsbUJBQW1COzs7O0FBQUcsQ0FBQyxLQUFvQixFQUFFLEVBQUU7SUFDbkQsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO1FBQzFGLE9BQU87WUFDTCxHQUFHLEVBQUUsS0FBSyxDQUFDLGlCQUFpQjtZQUM1QixHQUFHLEVBQUUsS0FBSyxDQUFDLGlCQUFpQjtTQUM3QixDQUFDO0tBQ0g7U0FBTTtRQUNMLE9BQU87WUFDTCxHQUFHLEVBQUUsS0FBSyxDQUFDLFFBQVE7WUFDbkIsR0FBRyxFQUFFLEtBQUssQ0FBQyxRQUFRO1NBQ3BCLENBQUM7S0FDSDtBQUNILENBQUMsQ0FBQTs7QUFLRCxNQUFNLE9BQU8sbUJBQW1COzs7Ozs7OztJQWtCOUIsWUFDdUMsWUFBcUIsRUFDbEQsT0FBMEIsRUFDMUIsT0FBbUIsRUFDbkIsSUFBWSxFQUNaLFFBQW1CO1FBSlUsaUJBQVksR0FBWixZQUFZLENBQVM7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R0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFOztzQkFDN0IsT0FBTyxHQUFHLG1CQUFtQixDQUFDLEtBQUssQ0FBQztnQkFFMUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDOUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDckMsQ0FBQyxDQUFBO1NBQ0YsQ0FBQztJQUNKLENBQUM7OztZQXJKRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGNBQWM7YUFDekI7Ozs7NENBb0JJLFFBQVEsWUFBSSxNQUFNLFNBQUMsT0FBTztZQXhDdkIsaUJBQWlCO1lBaEJ2QixVQUFVO1lBSVYsTUFBTTtZQU1OLFNBQVM7Ozt5QkE2QlIsS0FBSztrQ0FHTCxLQUFLO2dDQUdMLEtBQUs7c0NBR0wsS0FBSzs2QkFLTCxNQUFNOzs7O0lBZFAseUNBQ3lCOztJQUV6QixrREFDNEI7O0lBRTVCLGdEQUMyQjs7SUFFM0Isc0RBQzRDOzs7OztJQUU1QywrQ0FBOEI7O0lBRTlCLDZDQUE4Qzs7Ozs7SUFHNUMsMkNBQTBEOzs7OztJQUMxRCxzQ0FBa0M7Ozs7O0lBQ2xDLHNDQUEyQjs7Ozs7SUFDM0IsbUNBQW9COzs7OztJQUNwQix1Q0FBMkI7Ozs7O0FBK0gvQiw0QkFPQzs7O0lBTkMsaUNBQWlCOztJQUNqQixpQ0FBaUI7O0lBQ2pCLDBDQUEyQjs7SUFDM0IsMENBQTJCOztJQUMzQiw2QkFBa0I7O0lBQ2xCLDhCQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBTb3J0YWJsZSwge09wdGlvbnN9IGZyb20gJ3NvcnRhYmxlanMnO1xuaW1wb3J0IHtHTE9CQUxTfSBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHtTb3J0YWJsZWpzQmluZGluZ3N9IGZyb20gJy4vc29ydGFibGVqcy1iaW5kaW5ncyc7XG5pbXBvcnQge1NvcnRhYmxlanNTZXJ2aWNlfSBmcm9tICcuL3NvcnRhYmxlanMuc2VydmljZSc7XG5cbmV4cG9ydCB0eXBlIFNvcnRhYmxlRGF0YSA9IGFueSB8IGFueVtdO1xuXG5jb25zdCBnZXRJbmRleGVzRnJvbUV2ZW50ID0gKGV2ZW50OiBTb3J0YWJsZUV2ZW50KSA9PiB7XG4gIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnbmV3RHJhZ2dhYmxlSW5kZXgnKSAmJiBldmVudC5oYXNPd25Qcm9wZXJ0eSgnb2xkRHJhZ2dhYmxlSW5kZXgnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXc6IGV2ZW50Lm5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgb2xkOiBldmVudC5vbGREcmFnZ2FibGVJbmRleCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuZXc6IGV2ZW50Lm5ld0luZGV4LFxuICAgICAgb2xkOiBldmVudC5vbGRJbmRleCxcbiAgICB9O1xuICB9XG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc29ydGFibGVqc10nLFxufSlcbmV4cG9ydCBjbGFzcyBTb3J0YWJsZWpzRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KClcbiAgc29ydGFibGVqczogU29ydGFibGVEYXRhOyAvLyBhcnJheSBvciBhIEZvcm1BcnJheVxuXG4gIEBJbnB1dCgpXG4gIHNvcnRhYmxlanNDb250YWluZXI6IHN0cmluZztcblxuICBASW5wdXQoKVxuICBzb3J0YWJsZWpzT3B0aW9uczogT3B0aW9ucztcblxuICBASW5wdXQoKVxuICBzb3J0YWJsZWpzQ2xvbmVGdW5jdGlvbjogKGl0ZW06IGFueSkgPT4gYW55O1xuXG4gIHByaXZhdGUgc29ydGFibGVJbnN0YW5jZTogYW55O1xuXG4gIEBPdXRwdXQoKSBzb3J0YWJsZWpzSW5pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KEdMT0JBTFMpIHByaXZhdGUgZ2xvYmFsQ29uZmlnOiBPcHRpb25zLFxuICAgIHByaXZhdGUgc2VydmljZTogU29ydGFibGVqc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgem9uZTogTmdab25lLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgKSB7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoU29ydGFibGUgJiYgU29ydGFibGUuY3JlYXRlKSB7IC8vIFNvcnRhYmxlIGRvZXMgbm90IGV4aXN0IGluIGFuZ3VsYXIgdW5pdmVyc2FsIChTU1IpXG4gICAgICB0aGlzLmNyZWF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3AgaW4ga2V5b2YgU29ydGFibGVqc0RpcmVjdGl2ZV06IFNpbXBsZUNoYW5nZSB9KSB7XG4gICAgY29uc3Qgb3B0aW9uc0NoYW5nZTogU2ltcGxlQ2hhbmdlID0gY2hhbmdlcy5zb3J0YWJsZWpzT3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zQ2hhbmdlICYmICFvcHRpb25zQ2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNPcHRpb25zOiBPcHRpb25zID0gb3B0aW9uc0NoYW5nZS5wcmV2aW91c1ZhbHVlO1xuICAgICAgY29uc3QgY3VycmVudE9wdGlvbnM6IE9wdGlvbnMgPSBvcHRpb25zQ2hhbmdlLmN1cnJlbnRWYWx1ZTtcblxuICAgICAgT2JqZWN0LmtleXMoY3VycmVudE9wdGlvbnMpLmZvckVhY2gob3B0aW9uTmFtZSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50T3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gcHJldmlvdXNPcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgLy8gdXNlIGxvdy1sZXZlbCBvcHRpb24gc2V0dGVyXG4gICAgICAgICAgdGhpcy5zb3J0YWJsZUluc3RhbmNlLm9wdGlvbihvcHRpb25OYW1lLCB0aGlzLm9wdGlvbnNbb3B0aW9uTmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zb3J0YWJsZUluc3RhbmNlKSB7XG4gICAgICB0aGlzLnNvcnRhYmxlSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuc29ydGFibGVqc0NvbnRhaW5lciA/IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5zb3J0YWJsZWpzQ29udGFpbmVyKSA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNvcnRhYmxlSW5zdGFuY2UgPSBTb3J0YWJsZS5jcmVhdGUoY29udGFpbmVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5zb3J0YWJsZWpzSW5pdC5lbWl0KHRoaXMuc29ydGFibGVJbnN0YW5jZSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBwcml2YXRlIGdldEJpbmRpbmdzKCk6IFNvcnRhYmxlanNCaW5kaW5ncyB7XG4gICAgaWYgKCF0aGlzLnNvcnRhYmxlanMpIHtcbiAgICAgIHJldHVybiBuZXcgU29ydGFibGVqc0JpbmRpbmdzKFtdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc29ydGFibGVqcyBpbnN0YW5jZW9mIFNvcnRhYmxlanNCaW5kaW5ncykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ydGFibGVqcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBTb3J0YWJsZWpzQmluZGluZ3MoW3RoaXMuc29ydGFibGVqc10pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHsuLi50aGlzLm9wdGlvbnNXaXRob3V0RXZlbnRzLCAuLi50aGlzLm92ZXJyaWRlbk9wdGlvbnN9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgb3B0aW9uc1dpdGhvdXRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHsuLi4odGhpcy5nbG9iYWxDb25maWcgfHwge30pLCAuLi4odGhpcy5zb3J0YWJsZWpzT3B0aW9ucyB8fCB7fSl9O1xuICB9XG5cbiAgcHJpdmF0ZSBwcm94eUV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCAuLi5wYXJhbXM6IGFueVtdKSB7XG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB7IC8vIHJlLWVudGVyaW5nIHpvbmUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vU29ydGFibGVKUy9hbmd1bGFyLXNvcnRhYmxlanMvaXNzdWVzLzExMCNpc3N1ZWNvbW1lbnQtNDA4ODc0NjAwXG4gICAgICBpZiAodGhpcy5vcHRpb25zV2l0aG91dEV2ZW50cyAmJiB0aGlzLm9wdGlvbnNXaXRob3V0RXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zV2l0aG91dEV2ZW50c1tldmVudE5hbWVdKC4uLnBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0Nsb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydGFibGVJbnN0YW5jZS5vcHRpb25zLmdyb3VwLmNoZWNrUHVsbCh0aGlzLnNvcnRhYmxlSW5zdGFuY2UsIHRoaXMuc29ydGFibGVJbnN0YW5jZSkgPT09ICdjbG9uZSc7XG4gIH1cblxuICBwcml2YXRlIGNsb25lPFQ+KGl0ZW06IFQpOiBUIHtcbiAgICAvLyBieSBkZWZhdWx0IHBhc3MgdGhlIGl0ZW0gdGhyb3VnaCwgbm8gY2xvbmluZyBwZXJmb3JtZWRcbiAgICByZXR1cm4gKHRoaXMuc29ydGFibGVqc0Nsb25lRnVuY3Rpb24gfHwgKHN1Yml0ZW0gPT4gc3ViaXRlbSkpKGl0ZW0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgb3ZlcnJpZGVuT3B0aW9ucygpOiBPcHRpb25zIHtcbiAgICAvLyBhbHdheXMgaW50ZXJjZXB0IHN0YW5kYXJkIGV2ZW50cyBidXQgYWN0IG9ubHkgaW4gY2FzZSBpdGVtcyBhcmUgc2V0IChiaW5kaW5nRW5hYmxlZClcbiAgICAvLyBhbGxvd3MgdG8gZm9yZ2V0IGFib3V0IHRyYWNraW5nIHRoaXMuaXRlbXMgY2hhbmdlc1xuICAgIHJldHVybiB7XG4gICAgICBvbkFkZDogKGV2ZW50OiBTb3J0YWJsZUV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuc2VydmljZS50cmFuc2ZlciA9IChpdGVtczogYW55W10pID0+IHtcbiAgICAgICAgICB0aGlzLmdldEJpbmRpbmdzKCkuaW5qZWN0SW50b0V2ZXJ5KGV2ZW50Lm5ld0luZGV4LCBpdGVtcyk7XG4gICAgICAgICAgdGhpcy5wcm94eUV2ZW50KCdvbkFkZCcsIGV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnByb3h5RXZlbnQoJ29uQWRkT3JpZ2luYWwnLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgb25SZW1vdmU6IChldmVudDogU29ydGFibGVFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuZ2V0QmluZGluZ3MoKTtcblxuICAgICAgICBpZiAoYmluZGluZ3MucHJvdmlkZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0Nsb25pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS50cmFuc2ZlcihiaW5kaW5ncy5nZXRGcm9tRXZlcnkoZXZlbnQub2xkSW5kZXgpLm1hcChpdGVtID0+IHRoaXMuY2xvbmUoaXRlbSkpKTtcblxuICAgICAgICAgICAgLy8gZ3JlYXQgdGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS90YXV1XG4gICAgICAgICAgICAvLyBldmVudC5pdGVtIGlzIHRoZSBvcmlnaW5hbCBpdGVtIGZyb20gdGhlIHNvdXJjZSBsaXN0IHdoaWNoIGlzIG1vdmVkIHRvIHRoZSB0YXJnZXQgbGlzdFxuICAgICAgICAgICAgLy8gZXZlbnQuY2xvbmUgaXMgYSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgaXRlbSBhbmQgd2lsbCBiZSBhZGRlZCB0byBzb3VyY2UgbGlzdFxuICAgICAgICAgICAgLy8gSWYgYmluZGluZ3MgYXJlIHByb3ZpZGVkLCBhZGRpbmcgdGhlIGl0ZW0gZG9tIGVsZW1lbnQgdG8gdGhlIHRhcmdldCBsaXN0IGNhdXNlcyBhcnRpZmFjdHNcbiAgICAgICAgICAgIC8vIGFzIGl0IGludGVyZmVyZXMgd2l0aCB0aGUgcmVuZGVyaW5nIHBlcmZvcm1lZCBieSB0aGUgYW5ndWxhciB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSByZW1vdmUgaXQgaW1tZWRpYXRlbHkgYW5kIGFsc28gbW92ZSB0aGUgb3JpZ2luYWwgaXRlbSBiYWNrIHRvIHRoZSBzb3VyY2UgbGlzdC5cbiAgICAgICAgICAgIC8vIChldmVudCBoYW5kbGVyIG1heSBiZSBhdHRhY2hlZCB0byB0aGUgb3JpZ2luYWwgaXRlbSBhbmQgbm90IGl0cyBjbG9uZSwgdGhlcmVmb3JlIGtlZXBpbmdcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBkb20gbm9kZSwgY2lyY3VtdmVudHMgc2lkZSBlZmZlY3RzIClcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQoZXZlbnQuaXRlbS5wYXJlbnROb2RlLCBldmVudC5pdGVtKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKGV2ZW50LmNsb25lLnBhcmVudE5vZGUsIGV2ZW50Lml0ZW0sIGV2ZW50LmNsb25lKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQoZXZlbnQuY2xvbmUucGFyZW50Tm9kZSwgZXZlbnQuY2xvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UudHJhbnNmZXIoYmluZGluZ3MuZXh0cmFjdEZyb21FdmVyeShldmVudC5vbGRJbmRleCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2VydmljZS50cmFuc2ZlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3h5RXZlbnQoJ29uUmVtb3ZlJywgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAoZXZlbnQ6IFNvcnRhYmxlRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSB0aGlzLmdldEJpbmRpbmdzKCk7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBnZXRJbmRleGVzRnJvbUV2ZW50KGV2ZW50KTtcblxuICAgICAgICBiaW5kaW5ncy5pbmplY3RJbnRvRXZlcnkoaW5kZXhlcy5uZXcsIGJpbmRpbmdzLmV4dHJhY3RGcm9tRXZlcnkoaW5kZXhlcy5vbGQpKTtcbiAgICAgICAgdGhpcy5wcm94eUV2ZW50KCdvblVwZGF0ZScsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG59XG5cbmludGVyZmFjZSBTb3J0YWJsZUV2ZW50IHtcbiAgb2xkSW5kZXg6IG51bWJlcjtcbiAgbmV3SW5kZXg6IG51bWJlcjtcbiAgb2xkRHJhZ2dhYmxlSW5kZXg/OiBudW1iZXI7XG4gIG5ld0RyYWdnYWJsZUluZGV4PzogbnVtYmVyO1xuICBpdGVtOiBIVE1MRWxlbWVudDtcbiAgY2xvbmU6IEhUTUxFbGVtZW50O1xufVxuIl19